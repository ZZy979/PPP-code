# 第2章
* `//`：在一行中的`//`之后的内容都是注释。
* `<<`：C++的左移/输出运算符。
* C++：一种编程语言。
* 注释(comment)：用于描述程序做的事情，帮助人们读懂代码，会被编译器忽略。
* 编译器(compiler)：将源代码转换为目标代码的程序。
* 编译时错误(compile-time error)：由编译器发现的错误。
* `cout`：C++标准输出流。
* 可执行程序(executable)：可以在计算机上运行的程序。
* 函数(function)：一个命名的语句序列，可以使用给定参数调用，可能返回一个值。
* 头文件(header)：包含声明的文件，其中的声明用于在程序的不同部分之间共享接口，通常有后缀.h。
* 集成开发环境(IDE)：包括一个具有语法高亮、自动补全等功能的代码编辑器，以及其他编译、调试、运行代码功能的工具集合。
* `#include`：用于将头文件的内容包含进当前源文件的指令。
* 库(library)：一组类型、函数、类等，实现了一组功能，可能被很多程序所使用。
* 链接器(linker)：将目标代码和库文件组合在一起生成可执行程序的程序。
* `main()`：C++程序的入口函数。
* 目标代码(object code)：编译器的输出、链接器的输入。
* 输出(output)：计算生成的值，例如函数返回值或写到屏幕上的一行字符。
* 程序(program)：足够完整、可以被计算机执行的代码（可能与其相关联的数据一起）。
* 源代码(source code)：程序员编写的代码。
* 语句(statement)：函数中控制执行流程的基本单元，例如`if`语句、`for`语句、`while`语句、`do-while`语句、`switch`语句、表达式语句、声明等。

# 第3章
* 赋值(assignment)：给对象一个新值。
* `cin`：C++标准输入流。
* 连接(concatenation)：将两个字符串拼接在一起。
* 转换(conversion)：将一个类型的值转换为另一个类型。
* 声明(declaration)：命名一个对象的语句。
* 递减(decrement)：将变量的值减1。
* 定义(definition)：为一个对象分配内存空间的声明。
* 递增(increment)：将变量的值加1。
* 初始化(initialization)：给对象一个初值。
* 名字(name)：以字母开头、只包含字母、数字和下划线的字符序列。
* 缩小(narrowing)：从占用字节数较多、范围较大的类型转换为占用字节数较少、范围较小的类型。
* 对象(object)：用来保存一个指定类型的值的一些内存单元。
* 运算(operation)：对对象执行的某种动作，例如相加、取模、比较、输入/输出、函数调用等。
* 运算符(operator)：表示内置运算的符号，例如`+`、`*`、`&`等。
* 类型(type)：定义一组可能的值和一组操作，例如内置类型（`int`、`double`等），自定义类型。
* 类型安全(type safety)：当一个程序仅按照一个对象的类型的规则使用该对象时，该程序是类型安全的。
* 值(value)：内存中根据类型来解释的一组比特位。
* 变量(variable)：一个命名的对象。

# 第4章
* 抽象(abstraction)：对某个事物的描述，隐藏实现细节，指定通用接口。
* `begin()`：标准库容器（例如`vector`）返回开始位置迭代器的成员函数。
* 计算(computation)：某段代码的执行过程，一般接受一些输入，产生一些输出。
* 条件语句(conditional statement)：`if`语句或`switch`语句。
* 声明(declaration)：变量：命名一个对象的语句；函数：指定返回值类型、函数名和参数表的语句。
* 定义(definition)：变量：为一个对象分配内存空间的声明；函数：指定返回值类型、函数名、参数表和函数体的语句。
* 分治(divide and conquer)：将一个大的问题分为几个小问题分别解决。
* `else`：`if`语句的第二个分支部分。
* `end()`：标准库容器返回结束位置迭代器的成员函数。
* 表达式(expression)：运算符和名字的组合，产生一个值。
* `for`语句(`for`-statement)：指定初始化、循环条件和递增操作的循环语句。
* 基于范围的`for`语句(range-`for`-statement)：直接遍历一系列元素的循环语句。
* 函数(function)：一个指令序列，可以使用给定参数调用，可能返回一个值。
* `if`语句(`if`-statement)：根据条件在两个分支之间选择的语句。
* 递增(increment)：将变量的值加1。
* 输入(input)：计算所要使用的值，例如函数实参或用键盘敲入的字符。
* 迭代(iteration)：遍历一个数据结构的一系列元素。
* 循环(loop)：重复执行的一段代码，例如`for`语句或`while`语句。
* 左值(lvalue)：可以出现在赋值运算符左边的表达式，例如`x`、`v[1]`。
* 成员函数(member function)：在类中声明的函数。
* 输出(output)：计算生成的值，例如函数返回值或写到屏幕的一行字符。
* `push_back()`：标准库容器将一个元素添加到尾部的成员函数。
* 重复(repetition)：重复执行某些操作。
* 右值(rvalue)：可以出现在赋值运算符右边，不能出现在左边的表达式，例如`x+1`、`++p`。
* 选择(selection)：根据条件执行不同的操作。
* `size()`：标准库容器返回其大小（元素个数）的成员函数。
* `sort()`：标准库排序算法。
* 语句(statement)：控制执行流程的基本单元，例如表达式语句、`if`语句、`switch`语句、`for`语句、`while`语句、声明等。
* `switch`语句(`switch`-statement)：根据整数值在多个候选分支中进行选择的语句。
* `vector`：向量，提供连续存储、支持动态添加元素的标准库容器。
* `while`语句(`while`-statement)：在开头指定循环条件的循环语句。

# 第5章
* 参数错误(argument error)：参数不满足函数的要求导致的错误。
* 断言(assertion)：插入程序中的语句，声明在此处某些条件必须为真。
* `catch`：`try-catch`语句的一部分，处理一种特定类型的异常，也叫异常处理器。
* 编译时错误(compile-time error)：由编译器发现的错误，例如语法错误、类型错误。
* 容器(container)：容纳元素（其他对象）的对象，标准库容器包括`vector`、`list`、`map`等。
* 调试(debugging)：搜索、排除程序中错误的过程。
* 错误(error)：程序的实际行为与期望的不匹配。
* 异常(exception)：C++提供的错误处理机制；标准库提供的异常类型的基类。
* 不变式(invariant)：在程序某个位置必须始终成立的条件。
* 链接时错误(link-time error)：链接器将对象文件链接为可执行程序时发现的错误。
* 逻辑错误(logic error)：程序没有按照期望的方式运行。
* 后置条件(post-condition)：在退出一段代码（函数或循环）时必须成立的条件。
* 前置条件(pre-condition)：在进入一段代码（函数或循环）时必须成立的条件。
* 范围错误(range error)：访问容器元素时下标超过合法范围导致的错误，例如`vector::at()`函数。
* 需求(requirement)：对于程序期望行为的描述；函数对于其参数作出的假设。
* 运行时错误(run-time error)：程序运行中发现的错误。
* 语法错误(syntax error)：代码不符合C++语法规范导致的错误，属于编译错误的一种。
* 测试(testing)：查找程序中错误的系统化方法。
* `throw`：用于抛出异常的关键字。
* 类型错误(type error)：赋值给变量、传递给函数参数的值或表达式的类型与声明的不匹配导致的错误，属于编译错误的一种。

# 第6章
* 分析(analysis)：程序开发的第一个阶段，明确需求，给出对问题理解的描述，并编写需求规格说明书。
* `class`：用户自定义类型，可以包含数据成员、成员函数和成员类型；用户自定义类型的关键字。
* 类成员(class member)：在类中声明的变量、常量、函数或类型。
* 数据成员(data member)：在类中声明的变量。
* 设计(design)：程序开发的第二个阶段，给出系统的整体结构图，并确定实现包括哪些部分以及这些部分之间如何相互联系。
* 除以零(divide by zero)：除数为0。
* 文法(grammar)：一种描述形式语言的工具，由非终结符集合、终结符集合、产生式规则集合和开始符号四部分组成。
* 实现(implementation)：程序开发的第三个阶段，编写代码、调试和测试，确保程序完成预期的功能。
* 接口(interface)：一组声明，定义了一段代码如何被使用。例如，类的公有成员定义了该类的接口。
* 成员函数(member function)：在类中声明的函数。
* 语法分析器(parser)：负责按照文法的产生式规则将终结符序列构造成语法分析树的程序。
* `private`：类成员可见性关键字。类的私有成员只能被该类（相同或不同对象）的成员和友元访问。
* 原型(prototype)：小的、有限的程序，用来解决问题的关键部分。
* 伪代码(pseudo code)：用非正式的表示方法，而非编程语言描述的计算。
* `public`：类成员可见性关键字。类的公有成员在任何地方都可以访问。
* 语法分析器(syntax analyzer)：同parser。
* 单词(token)：文法中的终结符，例如表达式文法中的"+"、"("、浮点数等。
* 用例(use case)：程序的特定（通常是简单的）使用方式，可以测试程序的功能、展示其目的。

# 第7章
* 代码布局(code layout)：代码在文本编辑器中的格式，例如行长度、缩进、`case`标签的位置等。糟糕的代码布局可能隐藏bug。
* 注释(commenting)：用于描述程序的功能。好的注释是代码的重要组成部分，但最好的注释就是让代码本身来表达。
* 错误处理(error handling)：使用`try-catch`语句捕获程序抛出的异常，并输出错误信息或执行其他操作。
* 功能蔓延(feature creep)：向程序中添加过多功能（而只是为了“以防万一”）的倾向。
* 维护(maintenance)：程序首次发布后的工作，包括错误修复、功能增强、移至到新系统、改进错误处理、支持多语言、改进文档和性能调优。
* 恢复(recovery)：当错误发生时，程序能够捕获异常，清理遗留的“混乱”之后继续运行。
* 修订历史(revision history)：程序注释的一部分，用于记录每个版本做了哪些修正和改进。
* 程序框架(scaffolding)：在`main()`中调用其他函数，从而体现程序的主要逻辑。
* 符号常量(symbolic constant)：通过`const`声明引入的初始化后就不能再赋值的命名对象，通常用于为魔数引入一个名字，从而提高代码的可读性。
* 测试(testing)：查找程序中错误的系统化方法。

# 第8章
* 活动记录(activation record)：调用函数时创建的数据结构，包含参数、局部变量和其他函数返回到调用者所需的信息。
* 参数(argument)：传递给函数的值，也叫作实际参数(actual argument)。
* 参数传递(argument passing)：调用函数时向函数传递实际参数。
* 调用栈(call stack)：由活动记录组成的栈，调用函数时增长一个记录，函数返回时减少一个记录。
* 类作用域(class scope)：类内的区域。
* `const`：用于声明常量的关键字。
* `constexpr`：用于声明编译时常量或者可以在编译时求值的函数的关键字。
* 声明(declaration)：将名字引入作用域的语句。
* 定义(definition)：完整指定了所声明的实体并分配内存的声明。
* `extern`：用于声明在其他地方定义的全局变量的关键字。
* 前向声明(forward declaration)：在给出完整定义之前声明一个标识符，用于相互访问的类、相互调用的函数等。
* 函数(function)：一个命名的语句序列，可以使用给定参数调用，可能返回一个值。
* 函数定义(function definition)：包含函数体的函数声明。
* 全局作用域(global scope)：在任何其他作用域之外的区域。
* 头文件(header file)：包含声明的文件，通过`#include`包含到源文件中，用于在程序的不同部分之间共享接口。
* 初始值(initializer)：定义变量时用于初始化变量的值。
* 局部作用域(local scope)：语句块的`{}`之间或者函数的参数表。
* `namespace`：命名空间，命名的作用域，无需定义一个类型就能将类、函数、数据和类型组织成一个可识别的、命名的实体。
* 命名空间作用域(namespace scope)：嵌套于全局作用域或另一个命名空间中的命名的作用域。
* 嵌套块(nested block)：语句块中的语句块。
* 参数(parameter)：函数声明中代表实际参数的变量，也叫作形式参数(formal argument)，用于在函数被调用时访问实际参数。
* 传常量引用(pass-by-`const`-reference)：将实际参数的常量引用传递给函数，用于避免值拷贝，函数不能修改引用的对象。
* 传引用(pass-by-reference)：将实际参数的非常量引用传递给函数，用于避免值拷贝，允许函数修改被引用的对象。
* 传值(pass-by-value)：将实际参数的拷贝传递给函数，用于实际参数非常小的情况。
* 递归(recursion)：函数直接或间接调用自身。
* `return`：用于从函数中返回值的语句；在`void`函数中可以使用没有值的`return`语句从函数中返回。
* 返回值(return value)：函数向调用者返回的计算结果。
* 作用域(scope)：名字可以被访问的程序文本区域，包括全局作用域、命名空间作用域、类作用域、局部作用域和语句作用域。
* 语句作用域(statement scope)：例如for语句声明的循环变量。
* 技术细节(technicalities)：仅限于特定编程语言的语法、语义等细节，相对于适用于多种编程语言的通用程序设计概念。
* 未声明的标识符(undeclared identifier)：在一个名字声明之前就使用这个名字的错误。
* `using`声明(`using` declaration)：用于将命名空间中的一个名字引入当前作用域，语法：`using 命名空间名::成员名`
* `using`指令(`using` directive)：用于将指定命名空间中的所有名字引入当前作用域，语法：`using namespace 命名空间名`

# 第9章
* 内置类型(built-in types)：C++直接提供的类型，编译器无须借助源代码中提供的声明就知道如何表示这种类型的对象以及可以对它进行什么样的运算。例如`int`、`double`、`char*`等。
* `class`：类，一种用户自定义类型，由数据成员、成员函数和成员类型组成。
* `const`：用于声明常量或`const`成员函数的关键字。
* 构造函数(constructor)：与类同名、没有返回值的特殊成员函数，用于类对象的初始化，通常会建立一个不变式，并获取资源。
* 析构函数(destructor)：名字是类名前加一个`~`的特殊成员函数，用于删除对象前的清理工作，通常会释放资源。
* `enum`：用于定义枚举的关键字。
* 枚举(enumeration)：一种用户自定义类型，由一组命名的值（枚举项）组成。
* 枚举项(enumerator)：枚举中的值的名字。
* 辅助函数(helper function)：不需要直接访问类的表示的非成员函数，有助于保持接口最小化。例如，`Date`类的辅助函数包括`leapyear()`、`==`和`!=`等。
* 实现(implementation)：用户通过接口间接访问的部分，包含类的实现细节，使用标签`private:`标识。类的实现由私有数据成员和成员函数定义。
* 类内初始值(in-class initializer)：类成员声明中指定的初始值，这些初始值在所有构造函数中都是可用的。
* 内联(inlining)：对于内联函数，编译器直接将函数体嵌入到调用点，而不是生成函数调用指令。使用`inline`关键字声明的函数或在类内定义的成员函数是内联的。
* 接口(interface)：一组声明，定义了类如何被访问，使用标签`public:`标识。类的接口由公有成员函数定义。
* 不变式(invariant)：构成有效值的规则，对象的表示（状态）应该满足的某种条件，在构造函数创建对象、成员函数被调用以及返回时都应该成立。例如，Date类的不变式：一个Date对象必须对应日历上的某一天。
* 表示(representation)：类型“知道”如何表示对象需要的数据。
* `struct`：用于定义结构体的关键字。
* 结构体(structure)：成员默认为公有的类，主要用于成员可以取任意值、不能定义任何有意义的不变式的数据结构。
* 用户自定义类型(user-defined types)：非内置的类型，包括类和枚举。
* 有效状态(valid state)：满足不变式的对象的状态，也称为有效值。

# 第10章
* `bad()`：一种流状态，表示输入操作遇到严重错误（例如磁盘读故障），一般不可恢复。
* 缓冲区(buffer)：`istream`和`ostream`内部用于保存数据并与操作系统通信的数据结构。
* `clear()`：`istream`和`ostream`的成员函数，用于将流状态设置为给定值，默认为goodbit（即设置指定的状态位，清除其他状态位）。
* `close()`：`ifstream`和`ofstream`的成员函数，用于显式关闭文件。
* 设备驱动程序(device driver)：包含操作系统处理I/O设备细节的代码。用户程序通过I/O库访问设备驱动程序，使得不同设备源的I/O操作尽可能相似。
* `eof()`：一种流状态，表示到达文件结尾(EOF)。
* `fail()`：一种流状态，表示输入操作失败（例如格式错误），一般可恢复。
* 文件(file)：包含信息的字节序列，通常存储在计算机内存以外的地方，例如磁盘。
* `good()`：一种流状态，表示没有错误。
* `ifstream`：用于读文件的`istream`。
* 输入设备(input device)：输入操作的数据源，例如键盘、文件、网络连接、录音设备等。
* 输入运算符(input operator)：`>>`，可以为用户自定义类型定义输入运算符。
* `iostream`：(1) C++标准库头文件，提供了输入/输出流的定义；(2) C++标准库提供的既可输入又可输出的流类型。
* `istream`：C++标准库提供的输入流类型。
* `ofstream`：用于写文件的`ostream`。
* `open()`：`ifstream`和`ofstream`的成员函数，用于显式打开文件。
* `ostream`：C++标准库提供的输出流类型。
* 输出设备(output device)：输出操作的数据目的地，例如控制台、文件、网络连接、显示设备等。
* 输出运算符(output operator)：`<<`，可以为用户自定义类型定义输出运算符。
* 流状态(stream state)：`istream`和`ostream`用于表示错误状态的标志位，分为`good()`、`eof()`、`fail()`和`bad()`四种状态。
* 结构化文件(structured file)：具有特定格式的文本文件，例如JSON、HTML、XML等。
* 终结符(terminator)：标识一系列值结尾的字符，用于结束输入循环。例如，用'*'标识一个整数序列的结尾。
* `unget()`：`istream`的成员函数，用于将最近读取的一个字符放回输入流。

# 第11章
* 二进制(binary)：以2为基底的进制。
* 字符分类(character classification)：标准库头文件\<cctype\>定义了一组字符分类，例如判断一个字符是否是数字、是否是大写字母等。
* 十进制(decimal)：以10为基底的进制。
* `defaultfloat`：默认的浮点数操纵符，选择`fixed`和`scientific`中更精确的表示。
* 文件定位(file positioning)：在文件中选择一个特定的位置进行读写，通过输入/输出流的`seekg()`和`seekp()`函数实现。
* `fixed`：使用固定浮点表示的浮点数输出操纵符。
* 十六进制(hexadecimal)：以16为基底的进制。
* 不规则性(irregularity)：为了满足用户偏好而打破规则性，通常会增加程序复杂性。
* 面向行的输入(line-oriented input)：使用`getline()`函数一次读取一整行输入。
* 操纵符(manipulator)：用于改变输入/输出流的行为的函数。
* 非标准分隔符(nonstandard separator)：自定义读取字符串时使用的分隔符，而不是使用默认的空白符。
* `noshowbase`：不显示基底前缀的整数输出操纵符。
* 八进制(octal)：以8为基底的进制。
* 输出格式化(output formatting)：通过输出操纵符使得输出满足用户需求。
* 规则性(regularity)：一致地处理所有对象，能够给出最干净、最简单、最可维护以及通常最高效的代码。
* `scientific`：使用科学记数法表示的浮点数输出操纵符。
* `setprecision()`：设置域宽度的操纵符。
* `showbase`：显示基底前缀的整数输出操纵符。

# 第12章
* 颜色(color)：一种对光的视觉效应；GUI库中图形的线条颜色。
* 坐标(coordinates)：程序中通常使用坐标系来建模屏幕，每个像素由x（水平）坐标和y（垂直）坐标确定，屏幕左上角是坐标原点。
* 显示(display)：GUI系统的输出部分。
* 填充颜色(fill color)：GUI库中封闭图形内部区域的颜色。
* FLTK：Fast Light Toolkit，一个开源的C++ GUI库。
* 图形(graphics)：点、线、矩形、圆等几何形状。
* GUI：graphical user interface，图形用户界面。
* GUI库(GUI library)：通过调用操作系统的底层接口来绘制窗口和图形的代码库。
* HTML：Hyper Text Markup Language，超文本标记语言。
* 图像(image)：从图片文件加载的内容；图形在窗口上的绘制结果。
* JPEG：Joint Photographic Experts Group，一种图像文件格式，后缀名为.jpg或.jpeg。
* 线型(line style)：图形轮廓的类型（实线、虚线、点状线等）和粗细。
* 软件层(software layer)：软件分层是一种重要的软件设计思想。例如，通过将软件划分为展示层、业务逻辑层和数据库层，从而提高软件的可维护性和可扩展性。
* 窗口(window)：GUI系统的一个重要构件，由标题栏和画布两部分组成。
* XML：Extensible Markup Language，可扩展标记语言。

# 第13章
* 闭合形状(closed shape)：连接了最后一个点和第一个点的多线段，例如`Closed_polyline`。
* 颜色(color)：一种对光的视觉效应；GUI库中图形的线条颜色。
* 椭圆(ellipse)：平面上到两个点的距离之和为定值的点的轨迹。
* 填充(fill)：GUI库中封闭图形内部区域的颜色。
* 字体(font)：文字的外在形式特征。
* 字号(font size)：文字的大小。
* GIF：Graphics Interchange Format，一种图像文件格式，后缀名为.gif。
* 图像(image)：从图片文件加载的内容；图形在窗口上的绘制结果。
* 图像编码(image encoding)：用于存储图像的二进制文件编码方式，常用的有JPEG、GIF、PNG、BMP等。
* 不可见(invisible)：GUI库中形状的一种属性，不可见的形状不会被绘制。
* JPEG：Joint Photographic Experts Group，一种图像文件格式，后缀名为.jpg或.jpeg。
* 线(line)：连接两个点的线段。
* 线型(line style)：图形轮廓的类型（实线、虚线、点状线等）和粗细。
* 开放形状(open shape)：未连接最后一个点和第一个点的多线段，例如`Open_polyline`。
* 点(point)：表示坐标系中的一个位置，用坐标(x, y)表示。
* 多边形(polygon)：由至少三条互不相交的线段组成的闭合形状。
* 多线段(polyline)：由依次连接一系列点的线段组成的形状。
* 未命名对象(unnamed object)：未赋给变量的临时对象，例如：`T{arg1, arg2, ...}`或`new T{arg1, arg2, ...}`。
* `Vector_ref`：GUI库提供的用于保存和管理未命名对象的向量类型。
* 可见(visible)：GUI库中形状的一种属性，可见的形状将会被绘制。

# 第14章
* 抽象类(abstract class)：不能创建对象、只能作为基类的类，通常用于定义接口、表示抽象概念。可以通过将构造函数声明为`protected`或`private`，或声明纯虚函数来定义抽象类。
* 访问控制(access control)：通过将类的基类或成员声明为`public`、`protected`或`private`来控制其可见性。
* 基类(base class)：在类层次中被其他类派生的类。
* 派生类(derived class)：从一个或多个基类派生出的类。
* 分派(dispatch)：运行时多态。
* 封装(encapsulation)：保护类的实现细节不被直接访问。
* 继承(inheritance)：派生类继承自基类，也叫派生。派生类除了自己的成员外，还获得了基类的所有成员。
* 可变性(mutability)：在本章中是指通过封装来保证只有类自身能够修改其对象的状态。
* 对象布局(object layout)：类的数据成员在内存中一个接一个地存储。当使用继承时，派生类的成员被添加在基类成员之后。
* 面向对象(object-oriented)：使用类层次结构和虚函数的程序设计技术，允许通过接口对各种类型的对象进行操作，并允许通过派生对程序进行扩展。
  继承、多态和封装的使用是面向对象程序设计最常见的定义。
* 覆盖(override)：在派生类中定义一个与基类中名字和类型完全相同的函数，当用户通过基类指针或引用调用该函数时，调用的实际上是派生类的函数。
  覆盖要求基类的函数必须是虚函数。
* 多态(polymorphism)：在运行时根据对象类型来确定被调用的成员函数。
* `private`：访问控制关键字。私有成员只能被类自身访问；私有继承表示基类的`public`和`protected`成员对派生类是`private`。
* `protected`：访问控制关键字。受保护的成员只能被类自身和派生类访问；受保护继承表示基类的`public`和`protected`成员对派生类是`protected`。
* `public`：访问控制关键字。公有成员可以被所有函数访问；公有继承表示基类的`public`成员对派生类是`public`，`protected`成员对派生类是`protected`。
* 纯虚函数(pure virtual function)：必须被派生类覆盖的虚函数，语法`= 0`来声明。声明了纯虚函数的类是抽象的。除非所有的纯虚函数都被覆盖了，否则派生类仍然是抽象的。
* 子类(subclass)：派生类。
* 超类(superclass)：基类。
* 虚函数(virtual function)：可以被派生类覆盖的成员函数，是运行时多态的主要机制。
* 虚函数调用(virtual function call)：C++通过虚函数表机制来实现虚函数调用。
* 虚函数表(virtual function table)：类的所有虚函数的表，通常称为`vtbl`。实现虚函数调用的最常见方式是使具有虚函数的类的每个成员包含一个指向虚函数表的虚指针`vptr`。
  虚函数调用生成的代码简单地寻找`vptr`，通过它找到`vtbl`，然后调用其中正确的函数。

# 第15章
* 近似(approximation)：通过计算泰勒级数的前n项得到目标函数的近似值，计算的项数越多结果就越精确。
* 默认参数(default argument)：在函数声明中指定参数的初始值，如果调用者没有提供参数值，将使用此默认值。
* 函数(function)：在本章中指图形类`Function`，是`Shape`的子类，用于在窗口中绘制给定函数的图像。
* lambda：指Lambda表达式，C++11引入的语法，相当于未命名的函数，可以作为参数传递。例如`[](double x) { return cos(x) + slope(x); }`。
* 缩放(scaling)：在屏幕上绘制数据图时，通过缩放数据使其适应坐标轴定义的空间，本质上是数据到屏幕坐标的变换。
* 屏幕布局(screen layout)：程序使用屏幕空间的方式，涉及尺寸和偏移量的高精度计算。

# 第16章
* 按钮(button)：一种构件，能够在被点击时调用回调函数。
* 回调(callback)：当系统检测到特定的事件发生时调用的函数，例如GUI系统中按钮点击事件的回调函数。
* 控制台I/O(console I/O)：通过标准输入/输出流进行输入/输出。
* 控件(control)：构件。
* 控制反转(control inversion)：在GUI应用中，执行顺序的控制权从程序交给了构件（用户）。
* 对话框(dialog box)：一种弹出窗口，由标题、文字和按钮组成。
* GUI：图形用户界面(graphical user interface)。
* 菜单(menu)：一种构件，由多个菜单项组成。
* 软件层次(software layer)：用户程序通常运行在多“层”代码之上。例如，GUI应用涉及的“层”从上到下包括用户程序、自己的GUI库、FLTK、操作系统图形/GUI功能和设备驱动层。
* 用户界面/接口(user interface)：程序与用户的交互形式，常见的有控制台（命令行）、图形用户界面和网络浏览器。
* 可见/隐藏(visible/hidden)：构件可以设置为可见或不可见。
* 等待输入(waiting for input)：控制台程序执行到输入操作时停下来等待用户输入字符。
* 等待循环(wait loop)：GUI程序的其主体是一个无限循环，系统负责跟踪用户操作并调用相应的回调函数，在系统检测到程序感兴趣的动作之前，程序一直处于等待状态。
* 构件(widget)：用于定义通过GUI与程序进行交互的形式，例如按钮、输入框、菜单等。

# 第17章
* 地址(address)：用于指示内存位置的编号。
* 取地址运算符(address of) `&`：用于获得对象的地址。
* 分配(allocation)：从自由存储中获得一块内存空间。
* 转换(cast)：类型转换。
* 容器(container)：容纳其他对象的对象或类型。标准库容器包括`vector`、`list`、`map`等。
* 解引用运算符(dereference) `*`：用于访问指针指向的对象。
* 释放(deallocation)：将从自由存储分配的内存归还给自由存储。
* `delete`：释放由`new`分配的单个对象的内存，并调用对象的析构函数。
* `delete[]`：释放由`new`分配的数组的内存，并调用对象的析构函数。
* 解引用(dereference)：通过运算符`*`访问指针指向的对象。
* 析构函数(destructor)：一个特殊成员函数，当对象被销毁（离开作用域或者被`delete`）时析构函数将被隐式调用，用于确保对象被正确地销毁（释放了拥有的“资源”）。
  类`T`的析构函数名为`~T`。
* 自由存储(free store)：也称为堆存储，C++程序内存布局的一部分，可以通过`new`运算符动态分配的内存。
* 链接(link)：链表节点，保存一些数据和指向下一个节点的指针。
* 链表(list)：一种线性表数据结构，由若干节点组成，节点之间通过指针链接起来。标准库提供的链表容器是`list`。
* 成员访问运算符(member access) `->`：用于通过指针访问成员，`p->m`等价于`(*p).m`。
* 成员析构函数(member destructor)：在执行完类对象的析构函数体之后，编译器还会调用数据成员的析构函数和基类的析构函数，从而保证所有成员都被正确销毁。
* 内存(memory)：计算机内存是一个字节序列，这些字节从0开始编号。
* 内存泄露(memory leak)：如果使用`new`分配的内存没有被释放，并且离开了保存其地址的指针的作用域，则会发生内存泄露。
* `new`：从自由存储中分配内存，返回首字节的地址。`new T`和`new T[n]`分别为`T`类型的单个对象和数组分配内存，并调用对象的构造函数。
* 空指针(null pointer)：值为0的指针，不指向任何有效的对象。
* `nullptr`：C++11引入的关键字，表示空指针，可以隐式转换为任意类型的指针。
* 指针(pointer)：保存地址的对象称。在语法上`T*`是“指向`T`的指针”。
* 范围(range)：指针并不“知道”它指向多少个元素，因此通过指针访问元素时必须保证不会越界访问。
* 资源泄露(resource leak)：导致资源没有被释放的编程错误。
* 下标(subscripting)：使用下标运算符`[]`访问元素。
* 下标运算符(subscript) `[]`：用于通过数组或指针访问元素。`p[i]`等价于`*(p+i)`。
* `this`：指向当前对象（即调用成员函数的对象）的指针。只能在成员函数中使用，不能被赋值。
* 类型转换(type conversion)：从一种类型的值产生另一种类型的值。分为隐式类型转换和显式类型转换
  （使用C风格的转换`(T) v`或新式转换`static_cast<T>(v)`）。
* 虚析构函数(virtual destructor)：声明为`virtual`的析构函数，用于保证当通过基类指针`delete`一个由`new`创建的派生类对象时，派生类的析构函数将会被调用，从而派生类对象被正确销毁。
  如果一个类作为基类，则需要虚析构函数。
* `void*`：指向编译器不知道类型的内存的指针，不能被解引用。

# 第18章
* 数组(array)：一个固定大小的、连续的元素序列。
* 数组初始化(array initialization)：所有数组都可以使用对应元素类型的初始值列表进行初始化，字符数组还可以使用字符串常量初始化。
* 拷贝赋值(copy assignment)：接受自身类型的引用参数的赋值运算符，通常定义为`T& operator=(const T&)`，用于将一个`T`类型的对象赋值给另一个`T`类型的对象。
  如果一个类没有定义拷贝赋值，则默认拷贝所有成员（浅拷贝）。
* 拷贝构造函数(copy constructor)：接受自身类型的引用参数的构造函数，通常定义为`T(const T&)`，用于从一个`T`类型的对象初始化另一个`T`类型的对象。
  如果一个类没有定义拷贝构造函数，则默认拷贝所有成员（浅拷贝）。
* 深拷贝(deep copy)：拷贝指针指向的数据，从而两个指针指向不同的对象。例如标准库的`vector`、`string`等。
* 默认构造函数(default constructor)：无参数的构造函数，定义为`T()`，用于默认初始化，为类型定义默认值。
* 基本操作(essential operations)：定义一个类时需要提供的拷贝和赋值操作，包括构造函数、默认构造函数、拷贝构造函数、拷贝赋值、移动构造函数、移动赋值、析构函数等。
* 显式构造函数(`explicit` constructor)：使用关键字`explicit`定义的具有单个参数的构造函数，不能用于隐式转换（例如`vector v = 10;`）。
* 移动赋值(move assignment)：接受自身类型的右值引用参数的赋值运算符，通常定义为`T& operator=(T&&)`，用于将一个`T`类型的右值赋值给另一个`T`类型的对象。
* 移动构造函数(move constructor)：接受自身类型的右值引用参数的构造函数，通常定义为`T(T&&)`，用于从一个`T`类型的右值初始化另一个`T`类型的对象。
* 回文(palindrome)：从两端拼写相同的单词。例如，anna、petep和malayalam是回文，而ida和homesick不是回文。
* 浅拷贝(shallow copy)：只拷贝指针，从而两个指针指向同一个对象。

# 第19章
* `#define`：定义宏的预处理器指令，形式为`#define 名字 替换文本`或`#define 名字(参数表) 替换文本`。
* `at()`：`vector`的成员函数，带范围检查的元素访问，如果下标越界则抛出`out_of_range`异常。
* 基本保证(basic guarantee)：函数要么成功，要么抛出异常而不泄露任何资源。
* 异常(exception)：C++提供的错误处理机制，通过`throw`语句抛出异常对象，可以通过`try`语句捕获并处理。
* 保证(guarantees)：库函数的错误处理方式，包括基本保证、强保证和无抛出保证。
* 句柄(handle)：（资源的）拥有者。
* 实例化(instantiation)：模板实例化，同“特化”。
* 宏(macro)：C++预处理器的文本替换机制，通过`#define`指令定义宏，源代码中所有出现宏名字的地方都将被替换为对应的替换文本。
* 拥有者(owner)：控制资源的获取和释放的对象。例如，`vector`是底层数组的拥有者，`unique_ptr`是底层对象的拥有者。
* `push_back()`：`vector`的成员函数，将一个元素添加到尾部。
* RAII：资源获取即初始化(Resource Acquisition Is Initialization)，一种在程序中处理资源的技术，
  在对象的构造函数中获取资源，在对应的析构函数中释放资源。
* `resize()`：`vector`的成员函数，改变容器大小使其包含指定个数的元素。
* 资源(resource)：泛指程序可以获取和释放的实体，例如自由存储、锁、文件、线程、套接字等。
* 重抛出(re-throw)：见`throw;`。
* 自赋值(self-assignment)：将一个对象赋值给自身（例如`v=v`）。赋值运算符对于这种情况应该直接返回。
* `shared_ptr`：一种智能指针，通过引用计数来保证：当指向同一个对象的最后一个`shared_ptr`被销毁时，删除被指向的对象。
* 特化(specialization)：给定模板实参从模板生成类或函数。例如，`vector<double>`是`vector`的一个特化。
* 强保证(strong guarantee)：除了提供基本保证外，函数还确保所有可观测值（非局部变量）在失败后与调用函数时的值相同。
* 模板(template)：允许程序员使用类型或值参数化类或函数的机制，是支持C++泛型编程的基本语言特性。
* 模板参数(template parameter)：定义模板时的参数，包括类型参数和非类型参数。
* `this`：指向当前对象（即调用成员函数的对象）的指针。只能在成员函数中使用，不能被赋值。
* `throw;`：重新抛出当前处理的异常，只能用于`catch`子句中。
* `unique_ptr`：一种智能指针，拥有被指向对象的唯一所有权：当`unique_ptr`被销毁时，它将删除被指向的对象。

# 第20章
* 算法(algorithm)：用于解决某个问题的过程或方法，能生成结果的有限的计算步骤序列。
* `array`：静态连续数组，一种STL容器，在内置数组的基础上提供了迭代器和`size()`等。
* `auto`：C语言和C++11之前表示自动变量，即局部变量。C++11之后表示变量类型由初始值推导出来，例如`auto x = 123;`，则`x`的类型是`int`。
* `begin()`：标准库容器返回开始位置迭代器的成员函数。
* 容器(container)：容纳其他对象的对象或类型。标准库容器包括`vector`、`list`、`map`等。
* 连续的(contiguous)：容器的元素在内存中是依次排列的，例如内置数组、`array`、`vector`等。
* 双向链表(doubly-linked list)：每个节点具有前驱和后继节点指针的链表。例如标准库容器`list`。
* 元素(element)：容器中的一个对象。
* 空序列(empty sequence)：没有元素的序列。用迭代器表示为`begin() == end()`。
* `end()`：标准库容器返回结束位置迭代器的成员函数。
* `erase()`：STL容器成员函数，用于删除指定位置的元素。
* `insert()`：STL容器成员函数，用于将元素插入到指定位置。
* 迭代(iteration)：重复执行一段代码的动作；使用循环语句遍历数据结构，与递归相对。
* 迭代器(iterator)：STL对于引用序列元素的对象的抽象。迭代器指向序列中的一个位置，用于访问序列元素，提供`*`、`++`、`==`、`!=`等操作。
* 链表(linked list)：一种线性表数据结构，由若干节点组成，节点之间通过指针链接起来。分为单向链表和双向链表。
* 序列(sequence)：STL建模数据集合的核心概念。序列有一个开始和一个结尾，由一对迭代器指定。
* 单向链表(singly-linked list)：节点只有后继节点指针的链表。例如标准库容器`forward_list`。
* `size_type`：STL容器大小类型，通常作为`size()`的返回类型。
* STL：标准模板库(standard template library)，是ISO C++标准库的一部分，提供了容器（例如`vector`、`list`和`map`）
  和通用算法（例如`sort()`、`find()`和`accumulate()`）。
* 遍历(traversal)：通过循环（使用下标或迭代器）依次访问容器中的各个元素。
* `using`：（1）定义类型别名：`using 别名 = 类型;` （2）`using`声明：`using 命名空间名::成员名;` （3）`using`指令：`using namespace 命名空间名;`
* 类型别名(type alias)：使用`typedef`或`using`（C++11之后）为类型创建别名。
* `value_type`：STL容器元素类型。

# 第21章
* `accumulate()`：STL数值算法，累加序列中的值。
* 算法(algorithm)：用于解决某个问题的过程或方法，能生成结果的有限的计算步骤序列。标准库提供了大约60种标准算法，例如`sort()`、`find()`、`copy()`等。
* 应用运算符(application) `()`：也叫函数调用运算符，使对象可以像函数一样被调用。
* 关联容器(associative container)：存储键值对(key, value)的容器，可以基于key快速查找对应的value。STL关联容器包括`map`、`set`等。
* 平衡树(balanced tree)：如果一棵二叉树的左右子树的节点数大致相等，则这棵树是平衡的。
* `binary_search()`：STL二分搜索算法，判断给定值在有序序列中是否存在。
* `copy()`：STL算法，将一个序列的元素拷贝到另一个序列。
* `copy_if()`：STL算法，将一个序列的元素拷贝到另一个序列，但只拷贝满足谓词的元素。
* `equal_range()`：STL二分搜索算法，返回有序序列中等于给定值的范围的起止迭代器。
* `find()`：STL算法，返回给定值在序列中首次出现的位置。
* `find_if()`：STL算法，返回序列中使得谓词为真的第一个元素的位置。
* 函数对象(function object)：重载了函数调用运算符的对象。例如函数指针、Lambda表达式、`std::function`对象等。
* 泛型(generic)：STL算法是泛型的，可以被用于不同的数据类型，包括任何STL风格的序列、任何元素类型。
* 散列函数(hash function)：用于将给定的key转换为散列值（无符号整数）的函数。
* `inner_product()`：STL数值算法，计算两个序列的内积。
* lambda：指Lambda表达式，C++11引入的语法，相当于未命名的函数，可以作为参数传递。
* `lower_bound()`：STL二分搜索算法，返回有序序列中第一个不小于给定值的元素的迭代器。
* `map`：STL关联容器，使用平衡二叉搜索树实现的映射（键值对集合），按key的顺序存储元素，可以在O(log n)时间内基于key查找对应的value。
* 谓词(predicate)：接受若干个参数，返回布尔值的函数。例如`bool odd(int x) { return x % 2; }`。
* 搜索(searching)：在一个序列中查找满足条件的元素的算法，包括线性搜索（例如`find()`）和二分搜索（例如`binary_search()`）。
* 序列(sequence)：STL建模数据集合的核心概念。序列有一个开始和一个结尾，由一对迭代器指定。
* `set`：STL关联容器，使用平衡二叉搜索树实现的集合（只有key没有value的`map`），按key的顺序存储元素，可以在O(log n)时间内查找指定的key。
* `sort()`：STL排序算法。
* 排序(sorting)：重新排列序列中的元素，使得前面的元素小于后面的元素。
* 流迭代器(stream iterator)：操作对象是I/O流的迭代器，将`<<`和`>>`等I/O操作封装为`*`和`++`等迭代器操作。标准库提供的流迭代器包括`istream_iterator`和`ostream_iterator`。
* `unique_copy()`：STL算法，将一个序列的元素拷贝到另一个序列，不拷贝相邻的重复元素。
* `unordered_map`：STL关联容器，使用散列表实现的映射，key无序，可以在平均O(1)、最差O(n)时间内基于key查找对应的value。
* `upper_bound()`：STL二分搜索算法，返回有序序列中第一个大于给定值的元素的迭代器。
