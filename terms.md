# 第2章
* `//`：在一行中的`//`之后的内容都是注释。
* `<<`：C++的左移/输出运算符。
* C++：一种编程语言。
* 注释(comment)：用于描述程序做的事情，帮助人们读懂代码，会被编译器忽略。
* 编译器(compiler)：将源代码转换为目标代码的程序。
* 编译时错误(compile-time error)：由编译器发现的错误。
* `cout`：C++标准输出流。
* 可执行程序(executable)：可以在计算机上运行的程序。
* 函数(function)：一个命名的语句序列，可以使用给定参数调用，可能返回一个值。
* 头文件(header)：包含声明的文件，其中的声明用于在程序的不同部分之间共享接口，通常有后缀.h。
* 集成开发环境(IDE)：包括一个具有语法高亮、自动补全等功能的代码编辑器，以及其他编译、调试、运行代码功能的工具集合。
* `#include`：用于将头文件的内容包含进当前源文件的指令。
* 库(library)：一组类型、函数、类等，实现了一组功能，可能被很多程序所使用。
* 链接器(linker)：将目标代码和库文件组合在一起生成可执行程序的程序。
* `main()`：C++程序的入口函数。
* 目标代码(object code)：编译器的输出、链接器的输入。
* 输出(output)：计算生成的值，例如函数返回值或写到屏幕上的一行字符。
* 程序(program)：足够完整、可以被计算机执行的代码（可能与其相关联的数据一起）。
* 源代码(source code)：程序员编写的代码。
* 语句(statement)：函数中控制执行流程的基本单元，例如`if`语句、`for`语句、`while`语句、`do-while`语句、`switch`语句、表达式语句、声明等。

# 第3章
* 赋值(assignment)：给对象一个新值。
* `cin`：C++标准输入流。
* 连接(concatenation)：将两个字符串拼接在一起。
* 转换(conversion)：将一个类型的值转换为另一个类型。
* 声明(declaration)：命名一个对象的语句。
* 递减(decrement)：将变量的值减1。
* 定义(definition)：为一个对象分配内存空间的声明。
* 递增(increment)：将变量的值加1。
* 初始化(initialization)：给对象一个初值。
* 名字(name)：以字母开头、只包含字母、数字和下划线的字符序列。
* 缩小(narrowing)：从占用字节数较多、范围较大的类型转换为占用字节数较少、范围较小的类型。
* 对象(object)：用来保存一个指定类型的值的一些内存单元。
* 运算(operation)：对对象执行的某种动作，例如相加、取模、比较、输入/输出、函数调用等。
* 运算符(operator)：表示内置运算的符号，例如`+`、`*`、`&`等。
* 类型(type)：定义一组可能的值和一组操作，例如内置类型（`int`、`double`等），自定义类型。
* 类型安全(type safety)：当一个程序仅按照一个对象的类型的规则使用该对象时，该程序是类型安全的。
* 值(value)：内存中根据类型来解释的一组比特位。
* 变量(variable)：一个命名的对象。

# 第4章
* 抽象(abstraction)：对某个事物的描述，隐藏实现细节，指定通用接口。
* `begin()`：标准库容器（例如`vector`）返回开始位置迭代器的成员函数。
* 计算(computation)：某段代码的执行过程，一般接受一些输入，产生一些输出。
* 条件语句(conditional statement)：`if`语句或`switch`语句。
* 声明(declaration)：变量：命名一个对象的语句；函数：指定返回值类型、函数名和参数表的语句。
* 定义(definition)：变量：为一个对象分配内存空间的声明；函数：指定返回值类型、函数名、参数表和函数体的语句。
* 分治(divide and conquer)：将一个大的问题分为几个小问题分别解决。
* `else`：`if`语句的第二个分支部分。
* `end()`：标准库容器返回结束位置迭代器的成员函数。
* 表达式(expression)：运算符和名字的组合，产生一个值。
* `for`语句(`for`-statement)：指定初始化、循环条件和递增操作的循环语句。
* 基于范围的`for`语句(range-`for`-statement)：直接遍历一系列元素的循环语句。
* 函数(function)：一个指令序列，可以使用给定参数调用，可能返回一个值。
* `if`语句(`if`-statement)：根据条件在两个分支之间选择的语句。
* 递增(increment)：将变量的值加1。
* 输入(input)：计算所要使用的值，例如函数实参或用键盘敲入的字符。
* 迭代(iteration)：遍历一个数据结构的一系列元素。
* 循环(loop)：重复执行的一段代码，例如`for`语句或`while`语句。
* 左值(lvalue)：可以出现在赋值运算符左边的表达式，例如`x`、`v[1]`。
* 成员函数(member function)：在类中声明的函数。
* 输出(output)：计算生成的值，例如函数返回值或写到屏幕的一行字符。
* `push_back()`：标准库容器将一个元素添加到尾部的成员函数。
* 重复(repetition)：重复执行某些操作。
* 右值(rvalue)：可以出现在赋值运算符右边，不能出现在左边的表达式，例如`x+1`、`++p`。
* 选择(selection)：根据条件执行不同的操作。
* `size()`：标准库容器返回其大小（元素个数）的成员函数。
* `sort()`：标准库排序算法。
* 语句(statement)：控制执行流程的基本单元，例如表达式语句、`if`语句、`switch`语句、`for`语句、`while`语句、声明等。
* `switch`语句(`switch`-statement)：根据整数值在多个候选分支中进行选择的语句。
* `vector`：向量，提供连续存储、支持动态添加元素的标准库容器。
* `while`语句(`while`-statement)：在开头指定循环条件的循环语句。

# 第5章
* 参数错误(argument error)：参数不满足函数的要求导致的错误。
* 断言(assertion)：插入程序中的语句，声明在此处某些条件必须为真。
* `catch`：`try-catch`语句的一部分，处理一种特定类型的异常，也叫异常处理器。
* 编译时错误(compile-time error)：由编译器发现的错误，例如语法错误、类型错误。
* 容器(container)：容纳元素（其他对象）的对象，标准库容器包括`vector`、`list`、`map`等。
* 调试(debugging)：搜索、排除程序中错误的过程。
* 错误(error)：程序的实际行为与期望的不匹配。
* 异常(exception)：C++提供的错误处理机制；标准库提供的异常类型的基类。
* 不变式(invariant)：在程序某个位置必须始终成立的条件。
* 链接时错误(link-time error)：链接器将对象文件链接为可执行程序时发现的错误。
* 逻辑错误(logic error)：程序没有按照期望的方式运行。
* 后置条件(post-condition)：在退出一段代码（函数或循环）时必须成立的条件。
* 前置条件(pre-condition)：在进入一段代码（函数或循环）时必须成立的条件。
* 范围错误(range error)：访问容器元素时下标超过合法范围导致的错误，例如`vector::at()`函数。
* 需求(requirement)：对于程序期望行为的描述；函数对于其参数作出的假设。
* 运行时错误(run-time error)：程序运行中发现的错误。
* 语法错误(syntax error)：代码不符合C++语法规范导致的错误，属于编译错误的一种。
* 测试(testing)：查找程序中错误的系统化方法。
* `throw`：用于抛出异常的关键字。
* 类型错误(type error)：赋值给变量、传递给函数参数的值或表达式的类型与声明的不匹配导致的错误，属于编译错误的一种。

# 第6章
* 分析(analysis)：程序开发的第一个阶段，明确需求，给出对问题理解的描述，并编写需求规格说明书。
* `class`：用户自定义类型，可以包含数据成员、成员函数和成员类型；用户自定义类型的关键字。
* 类成员(class member)：在类中声明的变量、常量、函数或类型。
* 数据成员(data member)：在类中声明的变量。
* 设计(design)：程序开发的第二个阶段，给出系统的整体结构图，并确定实现包括哪些部分以及这些部分之间如何相互联系。
* 除以零(divide by zero)：除数为0。
* 文法(grammar)：一种描述形式语言的工具，由非终结符集合、终结符集合、产生式规则集合和开始符号四部分组成。
* 实现(implementation)：程序开发的第三个阶段，编写代码、调试和测试，确保程序完成预期的功能。
* 接口(interface)：一组声明，定义了一段代码如何被使用。例如，类的公有成员定义了该类的接口。
* 成员函数(member function)：在类中声明的函数。
* 语法分析器(parser)：负责按照文法的产生式规则将终结符序列构造成语法分析树的程序。
* `private`：类成员可见性关键字。类的私有成员只能被该类（相同或不同对象）的成员和友元访问。
* 原型(prototype)：小的、有限的程序，用来解决问题的关键部分。
* 伪代码(pseudo code)：用非正式的表示方法，而非编程语言描述的计算。
* `public`：类成员可见性关键字。类的公有成员在任何地方都可以访问。
* 语法分析器(syntax analyzer)：同parser。
* 单词(token)：文法中的终结符，例如表达式文法中的"+"、"("、浮点数等。
* 用例(use case)：程序的特定（通常是简单的）使用方式，可以测试程序的功能、展示其目的。

# 第7章
* 代码布局(code layout)：代码在文本编辑器中的格式，例如行长度、缩进、`case`标签的位置等。糟糕的代码布局可能隐藏bug。
* 注释(commenting)：用于描述程序的功能。好的注释是代码的重要组成部分，但最好的注释就是让代码本身来表达。
* 错误处理(error handling)：使用`try-catch`语句捕获程序抛出的异常，并输出错误信息或执行其他操作。
* 功能蔓延(feature creep)：向程序中添加过多功能（而只是为了“以防万一”）的倾向。
* 维护(maintenance)：程序首次发布后的工作，包括错误修复、功能增强、移至到新系统、改进错误处理、支持多语言、改进文档和性能调优。
* 恢复(recovery)：当错误发生时，程序能够捕获异常，清理遗留的“混乱”之后继续运行。
* 修订历史(revision history)：程序注释的一部分，用于记录每个版本做了哪些修正和改进。
* 程序框架(scaffolding)：在`main()`中调用其他函数，从而体现程序的主要逻辑。
* 符号常量(symbolic constant)：通过`const`声明引入的初始化后就不能再赋值的命名对象，通常用于为魔数引入一个名字，从而提高代码的可读性。
* 测试(testing)：查找程序中错误的系统化方法。

# 第8章
* 活动记录(activation record)：调用函数时创建的数据结构，包含参数、局部变量和其他函数返回到调用者所需的信息。
* 参数(argument)：传递给函数的值，也叫作实际参数(actual argument)。
* 参数传递(argument passing)：调用函数时向函数传递实际参数。
* 调用栈(call stack)：由活动记录组成的栈，调用函数时增长一个记录，函数返回时减少一个记录。
* 类作用域(class scope)：类内的区域。
* `const`：用于声明常量的关键字。
* `constexpr`：用于声明编译时常量或者可以在编译时求值的函数的关键字。
* 声明(declaration)：将名字引入作用域的语句。
* 定义(definition)：完整指定了所声明的实体并分配内存的声明。
* `extern`：用于声明在其他地方定义的全局变量的关键字。
* 前向声明(forward declaration)：在给出完整定义之前声明一个标识符，用于相互访问的类、相互调用的函数等。
* 函数(function)：一个命名的语句序列，可以使用给定参数调用，可能返回一个值。
* 函数定义(function definition)：包含函数体的函数声明。
* 全局作用域(global scope)：在任何其他作用域之外的区域。
* 头文件(header file)：包含声明的文件，通过`#include`包含到源文件中，用于在程序的不同部分之间共享接口。
* 初始值(initializer)：定义变量时用于初始化变量的值。
* 局部作用域(local scope)：语句块的`{}`之间或者函数的参数表。
* `namespace`：命名空间，命名的作用域，无需定义一个类型就能将类、函数、数据和类型组织成一个可识别的、命名的实体。
* 命名空间作用域(namespace scope)：嵌套于全局作用域或另一个命名空间中的命名的作用域。
* 嵌套块(nested block)：语句块中的语句块。
* 参数(parameter)：函数声明中代表实际参数的变量，也叫作形式参数(formal argument)，用于在函数被调用时访问实际参数。
* 传常量引用(pass-by-`const`-reference)：将实际参数的常量引用传递给函数，用于避免值拷贝，函数不能修改引用的对象。
* 传引用(pass-by-reference)：将实际参数的非常量引用传递给函数，用于避免值拷贝，允许函数修改被引用的对象。
* 传值(pass-by-value)：将实际参数的拷贝传递给函数，用于实际参数非常小的情况。
* 递归(recursion)：函数直接或间接调用自身。
* `return`：用于从函数中返回值的语句；在`void`函数中可以使用没有值的`return`语句从函数中返回。
* 返回值(return value)：函数向调用者返回的计算结果。
* 作用域(scope)：名字可以被访问的程序文本区域，包括全局作用域、命名空间作用域、类作用域、局部作用域和语句作用域。
* 语句作用域(statement scope)：例如for语句声明的循环变量。
* 技术细节(technicalities)：仅限于特定编程语言的语法、语义等细节，相对于适用于多种编程语言的通用程序设计概念。
* 未声明的标识符(undeclared identifier)：在一个名字声明之前就使用这个名字的错误。
* `using`声明(`using` declaration)：用于将命名空间中的一个名字引入当前作用域，语法：`using 命名空间名::成员名`
* `using`指令(`using` directive)：用于将指定命名空间中的所有名字引入当前作用域，语法：`using namespace 命名空间名`

# 第9章
* 内置类型(built-in types)：C++直接提供的类型，编译器无须借助源代码中提供的声明就知道如何表示这种类型的对象以及可以对它进行什么样的运算。例如`int`、`double`、`char*`等。
* `class`：类，一种用户自定义类型，由数据成员、成员函数和成员类型组成。
* `const`：用于声明常量或`const`成员函数的关键字。
* 构造函数(constructor)：与类同名、没有返回值的特殊成员函数，用于类对象的初始化，通常会建立一个不变式，并获取资源。
* 析构函数(destructor)：名字是类名前加一个`~`的特殊成员函数，用于删除对象前的清理工作，通常会释放资源。
* `enum`：用于定义枚举的关键字。
* 枚举(enumeration)：一种用户自定义类型，由一组命名的值（枚举项）组成。
* 枚举项(enumerator)：枚举中的值的名字。
* 辅助函数(helper function)：不需要直接访问类的表示的非成员函数，有助于保持接口最小化。例如，`Date`类的辅助函数包括`leapyear()`、`==`和`!=`等。
* 实现(implementation)：用户通过接口间接访问的部分，包含类的实现细节，使用标签`private:`标识。类的实现由私有数据成员和成员函数定义。
* 类内初始值(in-class initializer)：类成员声明中指定的初始值，这些初始值在所有构造函数中都是可用的。
* 内联(inlining)：对于内联函数，编译器直接将函数体嵌入到调用点，而不是生成函数调用指令。使用`inline`关键字声明的函数或在类内定义的成员函数是内联的。
* 接口(interface)：一组声明，定义了类如何被访问，使用标签`public:`标识。类的接口由公有成员函数定义。
* 不变式(invariant)：构成有效值的规则，对象的表示（状态）应该满足的某种条件，在构造函数创建对象、成员函数被调用以及返回时都应该成立。例如，Date类的不变式：一个Date对象必须对应日历上的某一天。
* 表示(representation)：类型“知道”如何表示对象需要的数据。
* `struct`：用于定义结构体的关键字。
* 结构体(structure)：成员默认为公有的类，主要用于成员可以取任意值、不能定义任何有意义的不变式的数据结构。
* 用户自定义类型(user-defined types)：非内置的类型，包括类和枚举。
* 有效状态(valid state)：满足不变式的对象的状态，也称为有效值。

# 第10章
* `bad()`：一种流状态，表示输入操作遇到严重错误（例如磁盘读故障），一般不可恢复。
* 缓冲区(buffer)：`istream`和`ostream`内部用于保存数据并与操作系统通信的数据结构。
* `clear()`：`istream`和`ostream`的成员函数，用于将流状态设置为给定值，默认为goodbit（即设置指定的状态位，清除其他状态位）。
* `close()`：`ifstream`和`ofstream`的成员函数，用于显式关闭文件。
* 设备驱动程序(device driver)：包含操作系统处理I/O设备细节的代码。用户程序通过I/O库访问设备驱动程序，使得不同设备源的I/O操作尽可能相似。
* `eof()`：一种流状态，表示到达文件结尾(EOF)。
* `fail()`：一种流状态，表示输入操作失败（例如格式错误），一般可恢复。
* 文件(file)：包含信息的字节序列，通常存储在计算机内存以外的地方，例如磁盘。
* `good()`：一种流状态，表示没有错误。
* `ifstream`：用于读文件的`istream`。
* 输入设备(input device)：输入操作的数据源，例如键盘、文件、网络连接、录音设备等。
* 输入运算符(input operator)：`>>`，可以为用户自定义类型定义输入运算符。
* `iostream`：(1) C++标准库头文件，提供了输入/输出流的定义；(2) C++标准库提供的既可输入又可输出的流类型。
* `istream`：C++标准库提供的输入流类型。
* `ofstream`：用于写文件的`ostream`。
* `open()`：`ifstream`和`ofstream`的成员函数，用于显式打开文件。
* `ostream`：C++标准库提供的输出流类型。
* 输出设备(output device)：输出操作的数据目的地，例如控制台、文件、网络连接、显示设备等。
* 输出运算符(output operator)：`<<`，可以为用户自定义类型定义输出运算符。
* 流状态(stream state)：`istream`和`ostream`用于表示错误状态的标志位，分为`good()`、`eof()`、`fail()`和`bad()`四种状态。
* 结构化文件(structured file)：具有特定格式的文本文件，例如JSON、HTML、XML等。
* 终结符(terminator)：标识一系列值结尾的字符，用于结束输入循环。例如，用'*'标识一个整数序列的结尾。
* `unget()`：`istream`的成员函数，用于将最近读取的一个字符放回输入流。

# 第11章
* 二进制(binary)：以2为基底的进制。
* 字符分类(character classification)：标准库头文件\<cctype\>定义了一组字符分类，例如判断一个字符是否是数字、是否是大写字母等。
* 十进制(decimal)：以10为基底的进制。
* `defaultfloat`：默认的浮点数操纵符，选择`fixed`和`scientific`中更精确的表示。
* 文件定位(file positioning)：在文件中选择一个特定的位置进行读写，通过输入/输出流的`seekg()`和`seekp()`函数实现。
* `fixed`：使用固定浮点表示的浮点数输出操纵符。
* 十六进制(hexadecimal)：以16为基底的进制。
* 不规则性(irregularity)：为了满足用户偏好而打破规则性，通常会增加程序复杂性。
* 面向行的输入(line-oriented input)：使用`getline()`函数一次读取一整行输入。
* 操纵符(manipulator)：用于改变输入/输出流的行为的函数。
* 非标准分隔符(nonstandard separator)：自定义读取字符串时使用的分隔符，而不是使用默认的空白符。
* `noshowbase`：不显示基底前缀的整数输出操纵符。
* 八进制(octal)：以8为基底的进制。
* 输出格式化(output formatting)：通过输出操纵符使得输出满足用户需求。
* 规则性(regularity)：一致地处理所有对象，能够给出最干净、最简单、最可维护以及通常最高效的代码。
* `scientific`：使用科学记数法表示的浮点数输出操纵符。
* `setprecision()`：设置域宽度的操纵符。
* `showbase`：显示基底前缀的整数输出操纵符。

# 第12章
* 颜色(color)：一种对光的视觉效应；GUI库中图形的线条颜色。
* 坐标(coordinates)：程序中通常使用坐标系来建模屏幕，每个像素由x（水平）坐标和y（垂直）坐标确定，屏幕左上角是坐标原点。
* 显示(display)：GUI系统的输出部分。
* 填充颜色(fill color)：GUI库中封闭图形内部区域的颜色。
* FLTK：Fast Light Toolkit，一个开源的C++ GUI库。
* 图形(graphics)：点、线、矩形、圆等几何形状。
* GUI：graphical user interface，图形用户界面。
* GUI库(GUI library)：通过调用操作系统的底层接口来绘制窗口和图形的代码库。
* HTML：Hyper Text Markup Language，超文本标记语言。
* 图像(image)：从图片文件加载的内容；图形在窗口上的绘制结果。
* JPEG：Joint Photographic Experts Group，一种图像文件格式，后缀名为.jpg或.jpeg。
* 线型(line style)：图形轮廓的类型（实线、虚线、点状线等）和粗细。
* 软件层(software layer)：软件分层是一种重要的软件设计思想。例如，通过将软件划分为展示层、业务逻辑层和数据库层，从而提高软件的可维护性和可扩展性。
* 窗口(window)：GUI系统的一个重要构件，由标题栏和画布两部分组成。
* XML：Extensible Markup Language，可扩展标记语言。

# 第13章
* 闭合形状(closed shape)：连接了最后一个点和第一个点的多线段，例如`Closed_polyline`。
* 颜色(color)：一种对光的视觉效应；GUI库中图形的线条颜色。
* 椭圆(ellipse)：平面上到两个点的距离之和为定值的点的轨迹。
* 填充(fill)：GUI库中封闭图形内部区域的颜色。
* 字体(font)：文字的外在形式特征。
* 字号(font size)：文字的大小。
* GIF：Graphics Interchange Format，一种图像文件格式，后缀名为.gif。
* 图像(image)：从图片文件加载的内容；图形在窗口上的绘制结果。
* 图像编码(image encoding)：用于存储图像的二进制文件编码方式，常用的有JPEG、GIF、PNG、BMP等。
* 不可见(invisible)：GUI库中形状的一种属性，不可见的形状不会被绘制。
* JPEG：Joint Photographic Experts Group，一种图像文件格式，后缀名为.jpg或.jpeg。
* 线(line)：连接两个点的线段。
* 线型(line style)：图形轮廓的类型（实线、虚线、点状线等）和粗细。
* 开放形状(open shape)：未连接最后一个点和第一个点的多线段，例如`Open_polyline`。
* 点(point)：表示坐标系中的一个位置，用坐标(x, y)表示。
* 多边形(polygon)：由至少三条互不相交的线段组成的闭合形状。
* 多线段(polyline)：由依次连接一系列点的线段组成的形状。
* 未命名对象(unnamed object)：未赋给变量的临时对象，例如：`T{arg1, arg2, ...}`或`new T{arg1, arg2, ...}`。
* `Vector_ref`：GUI库提供的用于保存和管理未命名对象的向量类型。
* 可见(visible)：GUI库中形状的一种属性，可见的形状将会被绘制。

# 第14章
* 抽象类(abstract class)：不能创建对象、只能作为基类的类，通常用于定义接口、表示抽象概念。可以通过将构造函数声明为`protected`或`private`，或声明纯虚函数来定义抽象类。
* 访问控制(access control)：通过将类的基类或成员声明为`public`、`protected`或`private`来控制其可见性。
* 基类(base class)：在类层次中被其他类派生的类。
* 派生类(derived class)：从一个或多个基类派生出的类。
* 分派(dispatch)：运行时多态。
* 封装(encapsulation)：保护类的实现细节不被直接访问。
* 继承(inheritance)：派生类继承自基类，也叫派生。派生类除了自己的成员外，还获得了基类的所有成员。
* 可变性(mutability)：在本章中是指通过封装来保证只有类自身能够修改其对象的状态。
* 对象布局(object layout)：类的数据成员在内存中一个接一个地存储。当使用继承时，派生类的成员被添加在基类成员之后。
* 面向对象(object-oriented)：使用类层次结构和虚函数的程序设计技术，允许通过接口对各种类型的对象进行操作，并允许通过派生对程序进行扩展。
  继承、多态和封装的使用是面向对象程序设计最常见的定义。
* 覆盖(override)：在派生类中定义一个与基类中名字和类型完全相同的函数，当用户通过基类指针或引用调用该函数时，调用的实际上是派生类的函数。
  覆盖要求基类的函数必须是虚函数。
* 多态(polymorphism)：在运行时根据对象类型来确定被调用的成员函数。
* `private`：访问控制关键字。私有成员只能被类自身访问；私有继承表示基类的`public`和`protected`成员对派生类是`private`。
* `protected`：访问控制关键字。受保护的成员只能被类自身和派生类访问；受保护继承表示基类的`public`和`protected`成员对派生类是`protected`。
* `public`：访问控制关键字。公有成员可以被所有函数访问；公有继承表示基类的`public`成员对派生类是`public`，`protected`成员对派生类是`protected`。
* 纯虚函数(pure virtual function)：必须被派生类覆盖的虚函数，语法`= 0`来声明。声明了纯虚函数的类是抽象的。除非所有的纯虚函数都被覆盖了，否则派生类仍然是抽象的。
* 子类(subclass)：派生类。
* 超类(superclass)：基类。
* 虚函数(virtual function)：可以被派生类覆盖的成员函数，是运行时多态的主要机制。
* 虚函数调用(virtual function call)：C++通过虚函数表机制来实现虚函数调用。
* 虚函数表(virtual function table)：类的所有虚函数的表，通常称为`vtbl`。实现虚函数调用的最常见方式是使具有虚函数的类的每个成员包含一个指向虚函数表的虚指针`vptr`。
  虚函数调用生成的代码简单地寻找`vptr`，通过它找到`vtbl`，然后调用其中正确的函数。
